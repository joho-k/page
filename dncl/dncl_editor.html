<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>DNCL実行環境（インデント対応版 + └対応）</title>
    <style>
        body {
            padding: 20px;
        }

        .code-area {
            display: flex;
            flex: 1;
            white-space: pre;
            height: 200px;
        }

        #line-numbers {
            font-size: 16px;
            text-align: right;
            padding-right: 8px;
            user-select: none;
            overflow: hidden;
        }

        #code {
            font-size: 16px;
            width: 100%;
            height: 200px;
            font-family: monospace;
        }

        #output {
            background: #f0f0f0;
            padding: 10px;
            min-height: 100px;
            white-space: pre-wrap;
        }

        #trace {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
        }

        #trace th,
        #trace td {
            border: 1px solid #ccc;
            padding: 6px 12px;
            text-align: center;
        }

        #trace td {
            color: #888;
        }

        #trace thead {
            background-color: #f0f0f0;
        }

        #trace tbody tr:nth-child(even) {
            background-color: #fafafa;
        }

        #trace .changed {
            font-weight: bold;
            color: #d00000;
            background-color: #fff0f0;
        }
    </style>
</head>

<body>
    <h2>DNCL実行環境（インデントと└でブロック管理）</h2>
    <!-- x = 2
もし x > 3 ならば:
│ 表示する("大きい")
そうでなくもし x == 2 ならば:
│ 表示する("x == 2")
そうでなければ:
└ 表示する("小さい")

sum = 0
i を 1 から 3 まで 1 ずつ増やしながら繰り返す:
└ sum = sum + i
表示する(sum)

関数 add (a, b):
│ c = a + b
│ もし a > b ならば:
│ │ print("入れ子1")
│ │ もし a > b ならば:
│ │ │ print("入れ子の入れ子1")
│ │ └ print("入れ子の入れ子2")
│ └ print("入れ子2")
└ c を返す

表示する(add(6,5)) -->
    <div class="code-area">
        <div id="line-numbers"></div>
        <textarea id="code" placeholder="DNCL風コードを入力してください">
sum = 0
i を 1 から 3 まで 1 ずつ増やしながら繰り返す:
└ sum = sum + i
表示する(sum)
        </textarea>
    </div>
    <br><br>
    <button onclick="runCode()">▶ 実行</button>
    <h3>出力:</h3>
    <div id="output"></div>
    <h3>実行ステップ</h3>
    <div id="trace"></div>

    <script>
        const textarea = document.getElementById("code");
        const lineNumbers = document.getElementById("line-numbers");

        function updateLineNumbers() {
            const lines = textarea.value.split('\n').length;
            lineNumbers.innerHTML = Array.from({ length: lines }, (_, i) => (i + 1)).join('<br>');
        }

        textarea.addEventListener('input', updateLineNumbers);
        textarea.addEventListener('scroll', () => {
            lineNumbers.scrollTop = textarea.scrollTop;
        });

        // 初期表示
        updateLineNumbers();

        function runCode() {
            const dncl = document.getElementById('code').value;
            const outputEl = document.getElementById('output');
            outputEl.textContent = '';

            const lines = dncl.split(/\r?\n/);
            let jsLines = [];
            let indentStack = [0];
            let varNames = new Set();

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmedLine = line.trimStart();

                const assignMatch = trimmedLine.match(/^([└│ ]*)\s*([a-zA-Z_]\w*)\s*=\s*(.+)$/);
                const assignLoopMatch = trimmedLine.match(/^([a-zA-Z_]\w*) を .+ から .+ まで .+ ずつ増やしながら繰り返す:/);

                if (assignMatch) varNames.add(assignMatch[2]);
                if (assignLoopMatch) varNames.add(assignLoopMatch[1]);

                // 「└　」で始まる行（1行ブロック）
                if (trimmedLine.includes('└')) {
                    const match = trimmedLine.match(/(└+)/);
                    const closeCount = match ? match[1].length : 1;
                    const content = trimmedLine.replace(/^.*└+\s*/, '');
                    const currentIndent = indentStack[indentStack.length - 1];

                    let jsLine = content
                        .replace(/^(.+?) を返す$/, 'return $1')
                        .replace(/^表示する\((.+)\)$/, 'print($1);')
                        .replace(/^print\((.+)\)$/, 'print($1);')
                        .replace(/要素数\((.+?)\)/g, '$1.length')
                        .replace(/整数\(\)/g, 'Math.random()')
                        .replace(/乱数\(\)/g, 'Math.floor()');

                    jsLines.push('  '.repeat(currentIndent) + jsLine);

                    for (let j = 0; j < closeCount; j++) {
                        if (indentStack.length > 1) {
                            const count = (line.match(/└/g) || []).length;
                            for (let k = 0; k < count; k++) {
                                indentStack.pop();
                                jsLines.push('  '.repeat(indentStack[indentStack.length - 1]) + '}');
                            }
                        }
                    }
                    continue;
                }


                const indent = (line.match(/^(│ )+/) || [''])[0].length / 2;
                const content = line.replace(/^(│ )+/, '').trim();
                let jsLine = content;

                const isElse = content.startsWith("そうでなければ:");

                if (isElse) {
                    jsLines.push('} else {');
                    indentStack.pop();
                    indentStack.push(indent);
                    continue;
                }

                // --- 「そうでなくもし」への対応 ---
                if (/^そうでなくもし .+ ならば:$/.test(content)) {
                    while (indent < indentStack[indentStack.length - 1]) {
                        indentStack.pop();
                        jsLines.push('  '.repeat(indentStack[indentStack.length - 1]) + '}');
                    }
                    jsLine = content.replace(/^そうでなくもし (.+) ならば:$/, '} else if ($1) {');
                    jsLines.push('  '.repeat(indent) + jsLine);
                    continue;
                }

                while (indent < indentStack[indentStack.length - 1]) {
                    jsLines.push('}');
                    indentStack.pop();
                }

                // 文法変換
                jsLine = jsLine.replace(/^もし (.+) ならば:$/, 'if ($1) {');
                jsLine = jsLine.replace(/^(.+) を (.+) から (.+) まで (.+) ずつ増やしながら繰り返す:$/, 'for (let $1 = $2; $1 <= $3; $1 += $4) {');
                jsLine = jsLine.replace(/^(.+) の間繰り返す:$/, 'while ($1) {');
                jsLine = jsLine.replace(/^表示する\((.+)\)$/, 'print($1);');
                jsLine = jsLine.replace(/^(.+?) を返す$/, 'return $1');
                jsLine = jsLine.replace(/要素数\((.+?)\)/g, '$1.length');
                jsLine = jsLine.replace(/^関数 (.+)\((.*?)\):$/, 'function $1($2) {');
                jsLine = jsLine.replace(/乱数\(\)/g, 'Math.random()');
                jsLine = jsLine.replace(/整数\(([^)]+)\)/g, 'Math.floor($1)');

                jsLines.push(jsLine);

                if (jsLine.endsWith('{')) {
                    indentStack.push(indent);
                }
            }

            while (indentStack.length > 1) {
                jsLines.push('}');
                indentStack.pop();
            }

            for (let i = 1; i < jsLines.length; i = i + 2) {
                const trimmedLine = jsLines[i - 1].trimStart();

                const assignMatch = trimmedLine.match(/^([└│ ]*)\s*([a-zA-Z_]\w*)\s*=\s*(.+)$/);
                const assignLoopMatch = trimmedLine.match((/^\s*for\s*\(\s*let\s+([a-zA-Z_]\w*)\s*=/));

                let varsCode = "";
                if (assignMatch) {
                    varsCode = ` vars.${assignMatch[2]} = ${assignMatch[2]};`;
                } else if (assignLoopMatch) {
                    varsCode = ` vars.${assignLoopMatch[1]} = ${assignLoopMatch[1]};`;
                }
                const addCode = trimmedLine !== ""
                    ? `recordStep(${Math.ceil(i / 2)});${`${varsCode}`}`
                    : "";
                jsLines.splice(i, 0, addCode);
            }
            console.log(jsLines.join("\n"));

            const finalCode = `
            let output = "";
            let traceTable = [];
            // 処理を追う用の変数
            const vars = {};

            function recordStep(step) {
                const snapshot = { "ステップ": step };
                for (const name of ${JSON.stringify([...varNames])}) {
                    try {
                        snapshot[name] = JSON.stringify(vars[name]);
                    } catch { snapshot[name] = "-"; }
                }
                traceTable.push(snapshot);
            }
            function print(...args) {
                output += args.join(" ") + "\\n";
            }
            try {
                ${jsLines.join('\n')}
            } catch (e) {
                output += "エラー: " + e.message;
            }
            return { output, traceTable };
            `;

            try {
                const result = new Function(finalCode)();
                outputEl.textContent = result.output;
                renderTraceTable(result.traceTable, [...varNames]);
            } catch (err) {
                outputEl.textContent = "実行時エラー: " + err.message;
            }
        }

        function renderTraceTable(traceTable, varNames) {
            const traceEl = document.getElementById("trace");
            traceEl.innerHTML = "";

            if (traceTable.length === 0) return;

            const table = document.createElement("table");

            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");
            ["実行行", ...varNames].forEach(col => {
                const th = document.createElement("th");
                th.textContent = col;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement("tbody");
            let prevRow = null;
            traceTable.forEach(row => {
                const tr = document.createElement("tr");
                ["ステップ", ...varNames].forEach(key => {
                    const td = document.createElement("td");
                    const value = row[key] ?? "-";

                    td.textContent = value;

                    if (prevRow && key !== "ステップ") {
                        const prevValue = prevRow[key] ?? "-";
                        if (prevValue !== value) {
                            td.classList.add("changed");
                        }
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
                prevRow = row;
            });
            table.appendChild(tbody);

            traceEl.appendChild(table);
        }
    </script>
</body>

</html>